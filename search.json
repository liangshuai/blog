[{"title":"npm publish如何过滤掉部分文件","url":"/2018/12/17/yuque/npm publish如何过滤掉部分文件/","content":"\n`npm publish` 的时候会把当前目录里面所有的文件都publish到npm仓库中， 但是往往有一部分目录和文件不想发布上去， 比如项目的源码、 `.editorconfig` 、 `tslint.json` 、 编译脚本等等信息， 发布出去对用户来说可能也没太大作用， 完全可以不发布这部分， 仅仅发布那些用户需要使用的相关文件， 那么该如何做呢？<br /><!-- more -->\n\n1. 使用 `.gitignore` 设置忽略哪些文件\n\n\n如果项目使用了git 管理代码版本的话， 可能会使用 `.gitignore` , 那么 `.gitignore` 里面设置的忽略文件在 `npm publish` <br />的时候也会被忽略.\n\n2. 使用 `.npmignore` 设置忽略哪些文件\n\n\n如果项目没有使用 git或者 没有 `.gitignore` 文件， 那么可以添加 `.npmignore` 文件来设置忽略哪些文件， `.npmignore` 的写法跟 `.gitignore` 的规则完全一样。 需要注意的是如果同时使用了 `.npmignore` 和 `.gitignore` 的话， 只有 `.npmignore` 会生效， 优先级比较高。\n\n3. 使用 `package.json` 的 `files` 字段选择发布哪些文件\n\n\n上面两种方式都是设置忽略哪些文件， 有时可能只想发布编译打包后的几个文件或者目录， 如果按照上面的设置会很麻烦， 这是可以直接在 package.json 中 `files` 字段设置发布哪些文件或目录， 这样的话， 只有这些目录或文件才会被publish.<br />同时需要说明的是这里的优先级是高于 `.npmignore` 和 `.gitignore` 的。\n\n4. npm默认带了一些规则\n\n\n除了上面的规则外， npm还有一些内置的规则，会被自动忽略的文件有\n```\n.*.swp\n._*\n.DS_Store\n.git\n.hg\n.npmrc\n.lock-wscript\n.svn\n.wafpickle-*\nconfig.gypi\nCVS\nnpm-debug.log\n```\n\nnode_modules下的所有文件也会被忽略。<br />另外还有一部分文件会被包含， 即便设置忽略也无效, 这些文件有\n```\npackage.json\nREADME (and its variants)\nCHANGELOG (and its variants)\nLICENSE / LICENCE\n```\n\n\n","tags":["npm"]},{"title":"JavaScript中for-in 和 for-of的区别","url":"/2018/12/14/yuque/JavaScript中for-in 和 for-of的区别/","content":"\nJS里面做循环最普通的是绝大多数编程语言都有的 `for ([initialization]; [condition]; [final-expression])` , 比如我们遍历一个数组可能会这样写\n```javascript\nfor (var i = 0, len = arr.length; i < len; i++) {\n    ...\n}\n```\n可以看出来这样写写法上比较复杂， 需要计算length<br /><!-- more --><br />ES5 中为了更方便的遍历数组， 提供了 `forEach` , 写法上简洁了很多\n```javascript\narr.forEach(item => { ... })\n```\n\n但是这种也会有一个很不方便的地方就是无法 `break` , 想象一下我们遍历数组， 可能第一个元素就满足某种条件而需要终止循环， 这样的写法是没有办法终止的， 只能傻乎乎的把数组全部遍历一遍。\n\n还有另外一种 `for-in ` 的循环， 它主要被用来遍历 `enumerable` 类型的对象， 比如\n```javascript\nvar obj = { a: 1, b: 2, c: 3 };\nfor (let key in obj) {\n    console.log(`key: ${key}, value: ${ obj[key] }`)\n}\n// key: a, value: 1\n// key: b, value: 2\n// key: c, value: 3\n```\n但是 `for-in` 形式的循环有个问题就是会遍历出原型链上的属性， 比如\n```javascript\naArray = [1,2,3]\naArray.name = 'demo'\nArray.prototype.arrCustomFn = function() {};\nObject.prototype.objCustomFn = function() {};\nfor(let index in aArray){\n    console.log(index);\n}\n\n// 0\n// 1\n// 2\n// name\n// arrCustomFn\n// objCustomFn\n```\n\n所以很多Lint系列会要求使用 `hasOwnProperty` 来先判断是否是自有的属性\n```javascript\nvar obj = { a: 1, b: 2, c: 3 };\nconst hasOwn = Object.prototype.hasOwnProperty\nfor (let key in obj) {\n    if (hasOwn.call(obj, key)) {\n        console.log(`key: ${key}, value: ${ obj[key] }`)\n    }\n}\n```\n\nES6中增加了 `for-of ` , 既保持了简洁的风格， 有弥补了forEach和for-in循环的不足之处， 而且应用范围很广泛， 所有的 **`Iterable`**` ` 对象， Iterable对象就是含有 `[Symbol.iterator]` 属性的对象， 比如String、Array、Set、<br />Map、arguments、NodeList等。 在循环中还可以直接使用 `break` 中断循环\n```javascript\nlet iterable = [1, 2, 3];\n\nfor (let value of iterable) {\n  console.log(value);\n}\n// 1\n// 2\n// 3\nfor (let value of iterable) {\n  if (value === 2) break;\n  console.log(value);\n}\n// 1\n```\n通过对比可以看出， 不同于for-in 遍历出来的是键名， for-of 遍历出来的是值， 所以如果需要遍历对象的话， 必须先使用Object.keys()\n```javascript\nfor (var key of Object.keys(someObject)) {\n  console.log(key + ': ' + someObject[key]);\n}\n```\n\n结论:\n\n- 不需要中途终止的可以直接使用 forEach\n\n- 需要遍历对象时优先使用for-in, 可能需要搭配 hasOwnProperty 使用\n\n- 遍历其它 Iterable 类型的集合时使用for-of\n\n\n\n","tags":["JavaScript"]},{"title":"HTTP仅指定Last-Modified和Date的缓存策略","url":"/2018/12/11/yuque/HTTP仅指定Last-Modified和Date的缓存策略/","content":"\n\n最近一个系统新版本上线之后，有用户反馈接口出现异常， 看了一下发现调用的接口是之前旧版本的， 在新版本中对该接口地址做了修改， 原有的旧接口已经不能使用了。 初步怀疑是缓存设置出了问题。<br />先去看了一下HTML中引用的资源文件名称是否打了Hash以及Hash新旧版本是否有变化，<br /><!-- more -->\n```html\n<script type=text/javascript src=/js/app.946c7f8807ee03c89c4b.js></script>\n```\n检查后发现有Hash并且Hash也发生了变化， 但是很明显用户请求到的还是旧的JS文件，  那么基本上可以确定用户端HTML文件发生了缓存， 并且没有正确刷新缓存。<br />检查了一下index.html的Response Headers\n```http\nHTTP/1.1 200\nServer: nginx/1.12.2\nDate: Tue, 11 Dec 2018 02:52:51 GMT\nContent-Type: text/html\nContent-Length: 933\nConnection: keep-alive\nX-UA-Compatible: IE=11\nX-Application-Context: application:prd,env:8080\nLast-Modified: Mon, 10 Dec 2018 02:08:46 GMT\nAccept-Ranges: bytes\nContent-Language: zh-CN\n```\n里面并没有指定缓存的Cache-Control、Expires， 缓存相关的字段只有Last-Modified和Date<br />那么在没有指定Cache-Control和Expires时浏览器使用的缓存方式是怎么样呢？<br />根据[HTTP协议第13.4 Response Cacheability](https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html)中所说\n> Unless specifically constrained by a cache-control (section [14.9](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9)) directive, a caching system MAY always store a successful response (see section [13.8](https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.8)) as a cache entry, MAY return it without validation if it is fresh, and MAY return it after successful validation. If there is neither a cache validator nor an explicit expiration time associated with a response, we do not expect it to be cached, but certain caches MAY violate this expectation (for example, when little or no network connectivity is available). A client can usually detect that such a response was taken from a cache by comparing the Date header to the current time.\n\n缓存系统 MAY 对一个成功的响应进行缓存， 不同浏览器的做法可能不一样， Chrome的处理方式是\n```\n(Date - Last-Modified) * 0.1\n```\n所以用户访问的时间正好落在了缓存的时间之内， 导致了使用了缓存。<br />问题的原因找到了， 解决的方案是在HTML的HTTP Response中明确指定Cache-Control或Expires。<br />另外， 同时还有两个问题\n\n1. 项目的index.html中http-equiv的meta中明确指定了Cache-Control， 为何没有生效?\n\n```html\n<meta http-equiv=pragma content=no-cache>\n<meta http-equiv=cache-control content=\"no-cache, no-store, must-revalidate\">\n<meta http-equiv=expires content=0>\n```\n这个疑问最终在这篇帖子中找到了答案 [https://stackoverflow.com/questions/49547/how-to-control-web-page-caching-across-all-browsers](https://stackoverflow.com/questions/49547/how-to-control-web-page-caching-across-all-browsers)\n```\nImportant to know is that when a HTML page is served over a HTTP connection, \nand a header is present in both the HTTP response headers and the HTML <meta http-equiv> \ntags, then the one specified in the HTTP response header will get precedence over the \nHTML meta tag. The HTML meta tag will only be used when the page is viewed from local\n disk file system via a file:// URL. See also W3 HTML spec chapter 5.2.2. \nTake care with this when you don't specify them programmatically, \nbecause the webserver can namely include some default values.\n\nGenerally, you'd better just not specify the HTML meta tags to avoid confusion by starters,\n and rely on hard HTTP response headers. Moreover, \nspecifically those <meta http-equiv> tags are invalid in HTML5. Only the http-equiv \nvalues listed in HTML5 specification are allowed.\n```\n\n2. 为何只有部分用户出现了这个问题\n\n\n这个问题的主要原因是用户行为会对缓存的策略产生影响， 比如在Chrome中\n\n- 如果在地址栏中输入URL或者通过书签访问\n\n\n这个时候 200 OK (from cache) 浏览器发现该资源已经缓存了而且没有过期，没有跟服务器确认，而是直接使用了浏览器缓存的内容。其中响应内容和之前的响应内容一模一样，例如其中的Date时间是上一次响应的时间。\n\n- F5/点击工具栏中的刷新按钮/右键菜单重新加载\n\n```\nCache-Control: max-age=0\nIf-Modified-Since: Fri, 15 Jul 2016 04:11:51 GMT\n```\n\n其中Cache-Control是Chrome强制加上的，而If-Modified-Since是因为获取该资源的时候包含了Last-Modified头部，浏览器会使用If-Modified-Since头部信息重新发送该时间以确认资源是否需要重新发送。 即使用协商缓存\n```http\n304(Not Modified)\n```\n，这样的响应信息很小，所以很快。\n\n- Ctrl+F5\n\n\n这个时候直接重新请求， 请求头会被Chrome自动加上\n```\nCache-Control: no-cache\nPragma: no-cache\n```\n\n\n","tags":["Cache","HTTP","Cache-Control"]},{"title":"Windows运行ElasticSearch.bat出错问题解决方案","url":"/2018/08/16/cannot_start_elasticsearch_on_windows/","content":"\n在Windows上下载了ElasticSearch的zip包， 解压之后命令行进入bin目录， 运行elasticsearch， 不能够成功运行\n提示\n\n```\n\\Java\\jdk1.8.0_151\\bin\\java.exe\" -cp \"C:\\Users\\<User Name>\\App\\elasticsearch-6.2.0\\lib*\" \"org.elasticsearch.tools.launchers.JvmOptionsParser\" \"C:\\Users\\<User Name>\\App\\elasticsearch-6.2.0\\config\\jvm.options\" || echo jvm_options_parser_failed\"`) was unexpected at this time.\n\n```\n<!-- more -->\nJava的路径是有问题的， 因为Java安装在了C:\\Program Files (x86)\\Java 路径下， 查看elasticsearch.bat文件， 找到出错的位置\n\n```\nfor /F \"usebackq\" %%a in (`\"%JAVA% -cp \"!ES_CLASSPATH!\" \"org.elasticsearch.tools.launchers.JvmOptionsParser\" \"!ES_JVM_OPTIONS!\" || echo jvm_options_parser_failed\"`) do set JVM_OPTIONS=%%a\n```\n在StackOverFlow( https://stackoverflow.com/questions/6474738/batch-file-for-f-doesnt-work-if-path-has-spaces )上看到有人说for /F后面的路径如果有空格的话会出错，  可以通过使用`CALL` 来解决，\n\n于是手工修改了elasticsearch.bat 把代码修改为\n\n ```\nfor /F \"usebackq delims=\" %%a in (`CALL %JAVA% -cp \"!ES_CLASSPATH!\" \"org.elasticsearch.tools.launchers.JvmOptionsParser\" \"!ES_JVM_OPTIONS!\" ^|^| echo jvm_options_parser_failed`) do set JVM_OPTIONS=%%a\n ```\n\n 修改之后便可以成功的启动ElasticSearch了。\n\n","tags":["Windows","ElasticSearch"]},{"title":"墙内查看Github Gist内容","url":"/2017/03/22/access-gist-content/","content":"\n## 命令行查看\n公司电脑不方便翻墙， 但是遇到个问题，正好Gist上有人演示怎么解决这个问题， 可是没有办法直接看到，想了想，之前用过C9提供的在线IDE， 环境位于墙外， 这个IDE自带terminal正好可以拿来用一用,\n先需要去https://c9.io/ 登录，直接使用Github账号就可以， 登录了创建Workspace， 进入workspace后就能看到下方的Terminal\n<!-- more -->\n\n### 认证获取Token\n使用自己的Github账号和密码，获取token\n```sh\ncurl -v -H \"Content-Type: application/json\" -u myUsername:myPassword -d '{\"scopes\":[\"gist\"],\"note\":\"gist\"}' https://api.github.com/authorizations\n```\n\n### 获取指定Gist的内容\n```sh\ncurl -v -H \"Authorization: token 上一步返回信息中的TOKEN\" https://api.github.com/gists/GistID\n```\n也可以做一些Gist的操作\n### 创建Gist\n```sh\ncurl -v -H \"Authorization: token 之前获取的token\" -d '{\"description\": \"a gist for a user with token api call\",\"public\": true,\"files\": {\"file1.txt\": {\"content\": \"String file contents\"}}}' https://api.github.com/gists\n```\n### 更新Gist\n```sh\ncurl -v --request PATCH -H \"Authorization: token 之前获取的token\" -d '{\"description\": \"updated gist\",\"public\": true,\"files\": {\"file1.txt\": {\"content\": \"String file contents are now updated\"}}}' https://api.github.com/gists/GistID\n```\n更多的操作可以参考以下链接\nhttps://developer.github.com/v3/gists/#list-a-users-gists\n\n### *更新*\n一些在线服务也可以查看\n\nroughdraft.io/gist-id 可以查看任意一个知道Gist ID的Gist\n\nhttp://www.gistboxapp.com/ 可以管理和创建自己Github账号下面的Gist\n","tags":["Gist","Github"]},{"title":"探索Bigpipe","url":"/2016/12/01/exploring-bigpipe/","content":"\n网站加载速度的快慢对用户体验是否良好起着至关重要的作用，据研究\n> 页面加载时间每增加1s，就会导致浏览量降低11%，客户满意度下降16%，转换率损失7%\n> 如果3秒内，网页还未加载完毕，57%的用户会放弃 \n> 每延长1秒，亚马逊一年就会减少16亿美元销售额\n> 74%的用户登录某网站时间超过5秒后就不会再登录这个网站\n> 60%的用户希望手机上的页面加载时间不要超过3秒\n\n由此可见 ，网页加载速度是多么的重要。页面加载速度的优化有很多种途径，本文探讨一下FaceBook提出的`Bigpipe技术`，该技术对于比较复杂的页面具有非常明显的作用。\n<!-- more -->\n### 基本思路\nBigpipe的基本思路是将页面划分为多个不同的块， 一般来说这些块是相互独立的，如下图所示，每一块称作一个`pagelet`  当用户请求页面时，服务器端分块处理内容，分块输出响应内容，客户端分块显示，从而使得各个块的处理和渲染得以并发进行。\n![enter image description here](http://7u2s4m.com1.z0.glb.clouddn.com/image.jpg) \n\n先来看一下网页加载流程\n![page load flow](http://7u2s4m.com1.z0.glb.clouddn.com/%E6%B5%8F%E8%A7%88%E5%99%A8.png)\n这个流程从请求到页面完整呈现出来存在大量的资源闲置， 比如浏览器请求结束到浏览器接收到服务器端响应这段时间是完全空闲的， 服务器端也有大量的闲置时间， 使用pagelet之后服务器持续分块输出内容到浏览器，浏览器持续不断的渲染各个pagelet，从而使得加载速度得到提升。\n![enter image description here](http://7u2s4m.com1.z0.glb.clouddn.com/4.png)\n\n![enter image description here](http://7u2s4m.com1.z0.glb.clouddn.com/5.png)\n\n### Bigpipe实现原理\n要实现BigPipe需要服务器先返回页面的框架结构（没有闭合body和html标签），然后需要能够持续的输出各个pagelet到页面，这就需要使用HTTP1.1 支持的[分块传输编码](https://en.wikipedia.org/wiki/Chunked_transfer_encoding)  ,  如果一个HTTP消息（请求消息或应答消息）的`Transfer-Encoding`消息头的值为`chunked`，那么，消息体由数量未定的块组成，每一块有自己的大小指示器，并以最后一个大小为`0`的块为结束, 这种编码允许发送端能动态生成内容，并能携带让接收端判断消息是否接收完整的有用信息。Big Pipe 完成这样的传输只需要使用一个连接, 不需要额外的请求， 相对于Ajax取数据的方式节省了多次HTTP连接的代价。\n对于浏览器端，由于页面的框架结构是`没有闭合body和html标签`的文档, 此时浏览器会把已经接收到的dom渲染出来(如果还有css, 也渲染上).  此时由于TCP连接还没有断开, body和html还没有闭合, 服务器可以继续推送更多的dom或者script到浏览器。\n![HTTP Chunked](http://7u2s4m.com1.z0.glb.clouddn.com/BEiVV.gif)\n\n上图是HTTP Chunked的一个例子， 每一个消息体都有一个16进制的大小指示器，并且以大小为0 的结束。\n\n### Node.js 简单实现\nNode.js http模块Response的write使用的就是分块传输编码， 这里使用Node.js简单实现一个BigPipe示例\n```js\nvar http = require('http'),\n\tfs = require('fs'),\n\tport = 8888,\n\tserver,\n\thandle;\n\nhandle = function(req, res){\n\tvar html = '',\n\t\tcontainers = ['header', 'content', 'footer'];\n\n\tres.writeHead(200, { 'Content-Type': 'text/html' });\n\thtml = fs.readFileSync(__dirname + \"/layout.html\").toString();\n\tres.write(html);\n\tcontainers.forEach(function(item){\n\t\tres.write('<script>bigpipe.render(\"#' + item + '\",\"module ' + item + '\");</script>');\n\t});\n\tres.write('</body></html>');\n\tres.end();\n}\n\nserver = http.createServer(handle);\nserver.listen(port, function(){\n    console.log(\"Server listening on: http://localhost:%s\", port);\n});\n```\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>BigPipe Testing</title>\n\t<script type=\"text/javascript\">\n\t\tvar BigPipe = function() {\n\t\t\tvar _render;\n\n\t\t\t_render = function(selector, html) {\n\t\t\t\tdocument.querySelector(selector).innerHTML = html;\n\t\t\t};\n\t\t\treturn {\n\t\t\t\trender: _render\n\t\t\t};\n\t\t};\n\t\tvar bigpipe = new BigPipe();\n\t</script>\n\n</head>\n<body>\n\t<div id=\"header\"></div>\n\t<div id=\"content\"></div>\n\t<div id=\"footer\"></div>\n```\n","tags":["Bigpipe","Node.js","Koa","Async"]},{"title":"JavaScript一些实用的技巧","url":"/2016/08/10/javascript-tips/","content":"最近看了很多开源项目的源码，感觉学到了不少东西，也学到了很多比较碎的技巧。JavaScript小技巧实在是太多，把这些小技巧和之前知道的一起总结一下，并且持续更新，权当是备忘。\n\n<!-- more -->\n\n### this.length >>> 0\n无符号右移运算，该操作常见于数组遍历，比如玉伯曾经发布的es5-safe模块里面有大量的该操作。作用是确保.length 是一个0到2^32的正整数\n* 所有非数字的被转换成0\n* -1 转换成 0\n* 负数转换成正整数\n* 浮点数相当于执行Math.floor\n\n```js\n1>>>0            === 1\n-1>>>0           === 0xFFFFFFFF          -1>>0    === -1\n1.7>>>0          === 1\n0x100000002>>>0  === 2\n1e21>>>0         === 0xDEA00000          1e21>>0  === -0x21600000\nInfinity>>>0     === 0\nNaN>>>0          === 0\nnull>>>0         === 0\n'1'>>>0          === 1\n'x'>>>0          === 0\nObject>>>0       === 0\n```\n### ~index\n在查找某字符串或者数组元素在字符串或者数组里面的索引时，如果不存在index都为-1， 这个时候用~index 如果index为 -1 会被转换成0, 相当于false\n```js\nvar idx = str.indexOf('a');\nif(idx > -1){\n\tdoSomething();\n}\n(idx > -1) && doSomething();\n~idx && doSomething()\n```\n### void 0\nvoid 0 是用来替换undefined的， 由于undefined在JavaScript中并非关键字， 我们可以直接给undefined赋值从而修改了undefined，由此来看undefined并不安全。 void 0 实际上总是返回undefined值，所以更加安全，而且相对来说也更加短，节省字符数。\n```js\nundefined = 123; //undefined 可以被赋值\n```\n### (0,eval)('this')\n\n先上代码\n```js\nvar _global = (function(){ \n\treturn this || (0,eval)(\"this\"); \n}());\n```\n用于获取全局对象, 可以兼容浏览器和Node.js， 严格模式和非严格模式。 \nthis 在非严格模式下在浏览器端指向window，在Node.js里面指向global或者GLOBAL (Node.js源码里面这样写的 `global = this;global.GLOBAL = global;` ),\n可是在严格模式下this却是undefined。\n而(0,eval)(\"this\") 总是能够返回全局对象， 那么为什么不直接调用eval('this')呢？\n```\nvar x = 'outer';\n(function() {\n  var x = 'inner';\n  eval('console.log(\"直接调用 Eval:\" + x)'); \n  (1,eval)('console.log(\"间接调用Eval: \" + x)'); \n})();\n```\n\n> 直接调用 Eval:inner\n> 间接调用Eval: outer\n\n所以如果直接调用的话可能会返回当前作用域this。\n\n### Date格式化\n经常会遇到需要格式化日期时间为 yyyy-MM-dd HH:mm:ss格式，这里有种比较简单的方法\n```js\nvar date = new Date();\nvar result = date.toLocaleString('zh-CN', { hour12: false })\n  .replace(/\\//g, '-').replace(/\\b\\d\\b/g, '0$&');\n```\n\n### 取月份天数\n\n```js\nnew Date(year, month + 1, 0).getDate();\n```\nnew Date()第三个参数为0 ，并且month 为 month + 1 是返回的是当前month的最后一天，即是月份的天数。\n","tags":["JavaScript"]},{"title":"Chrome调试动态创建的JS","url":"/2016/08/06/debug-dynamically-loaded-javascript/","content":"\nChrome开发者工具的Debug在开发JS时非常有用， 可是现在越来越多的JS框架都会在运行时动态添加或加载JS脚本， 比如很多JS模板引擎， 就可能添加生成的JS文件，这个时候调试起来并不像普通JS那样直接在Chrome Developer Tools 的`Sources` Tab下面直接看到，造成调试脚本的不便。\n\n<!-- more -->\n\n不过Chrome提供了一种简单的方式，可以直接看到添加的脚本，并且可以打BreakPoints。\n\n```html\n<!doctype html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>调试动态创建的JS</title>\n\t<link rel=\"canonical\" href=\"http://liangshuai.me/\" >\n</head>\n<body>\n\t\n<script type=\"text/javascript\">\n(function(){\n\tvar script = document.createElement('script');\n\tvar head = document.getElementsByTagName('head')[0];\n    script.setAttribute('type', 'text/javascript');\n    script.text = 'var test = 123; \\nconsole.log(test);\\n//# sourceURL=debugDynamicScripts.js';\n    head.appendChild(script);\n})();\n\t\n</script>\n</body>\n</html>\n```\n\n上面的例子中`script.text` 就相当于动态生成的JS， 如果想要在Sources里面看到的话 只需要在结尾添加上`\\n//# sourceURL=` 后面跟JS的文件名就可以了。这样动态创建JS文件就能在Sources下面的no domain下面看到。\n\n![Debug Dynamic Script](https://ooo.0o0.ooo/2017/03/04/58ba0a459b919.png)\n\n不过这个时候页面DOM中也会被添加了script标签以及脚本， 如果要创建的脚本过多可能造成DOM臃肿。 实际上在`appendChild` 之后就可以直接`removeChild` 掉了。脚本依旧能够看到并且可以执行。\n\n```js\nhead.appendChild(script);\nhead.removeChild(script);\n```\n","tags":["Chrome","JavaScript","Debug"]},{"title":"LeetCode算法题 -- Zigzag Conversion","url":"/2016/07/06/zigzag-conversion/","content":"\n原题：\n\nThe string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\n<!-- more -->\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string text, int nRows);\nconvert(\"PAYPALISHIRING\", 3) should return \"PAHNAPLSIIGYIR\".\n\n题目的大意是给定一个字符串和行数，然后之字形转换字符串，按行输出结果。 比如\"zigzagconversion\"转换成4行的之字形如下：\n\n![ZigZag Conversion](http://7u2s4m.com1.z0.glb.clouddn.com/zigzag-conversion.png)\n\n按行输出的结果就是`zcsigoriganeozvn`.\n\n要求按行输出的话就要确定每一行的字符序列， 通过观察发现第一行和最后一行的规律是相邻的相隔 `2 * rowNum - 2` 个，\n\n中间的那些行比较特殊， 如上图中的 `g` 、 `r` 、 `a`、 `e` , 除了这几个之外其余的也是遵循相邻的相隔`2 * rowNum - 2`个， 进一步观察发现第 2 行 中的 `g` 、 `r` 依次是`o`、`i` 减 2， 第 3 行 中的 `a` 、 `e` 依次是`n`、`o` 减 4，  即 第 i 行的元素依次是`i`、 `i + 2 * rowNum - 2 - 2 * i`、 `i + 2 * (2 * rowNum - 2) - 2 * i`、`...`.\n\n最终的JavaScript实现如下：\n\n```js\n/**\n * @param {string} s\n * @param {number} numRows\n * @return {string}\n */\nvar convert = function(s, numRows) {\n   var len = s.length;\n   var result = [];\n   var push = [].push;\n   var index = 0;\n   var skip = 2 * numRows - 2;\n   var i = 0;\n\n   if(numRows === 1) {\n   \t\treturn s;\n   }\n\n   for(; i < numRows; i++) {\n   \t\tindex = i;\n   \t\twhile(index < len) {\n   \t\t\tpush.call(result, s[index]);\n   \t\t\t(i !== 0 && i !== numRows -1 && (index + skip - 2 * i < len)) && (push.call(result, s[index + skip - 2 * i]));\n   \t\t\tindex += skip;\n   \t\t}\n   }\n   return result.join('');\n};\n```\n\n时间复杂度为O(n).\n\n\n\n","tags":["Leetcode","Algorithm","Zigzag"]},{"title":"JavaScript的一些坑","url":"/2016/06/07/wtf-javascript/","content":"\nJavaScript作为一门同时结合了函数式编程和面向对象编程的语言，使用起来非常的宽松灵活。但是由于其诞生之初仓促的设计([Javascript诞生记](http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html)) 、设计之初并没有同时结合函数式编程和面向对象编程的先例、过早标准化等问题，导致使用过程中经常会遇到各种问题。本文总结一些问题，部分是可能语言上的缺陷，也有部分属于用法的问题。\n\n<!-- more -->\n\n### 1. 整数上调用Number.prototype的方法\n\nNumber.prototype里面有toFixed()、toLocaleString()、toString()、valueOf()、toSource()等方法，直接调用的话会报错，以toString()为例\n\n```js\n3.toString()\n3..toString()\n(3).toString()\n3 + '' // 推荐的转换姿势\n```\n\n上面的第一行会报\n> Uncaught SyntaxError: Unexpected token ILLEGAL(…)\n\n该问题的原因是当在整数后调调用toString()时，JavaScript发现整数后面的点后，会期望遇到的是一个浮点数，结果点后面是toString()，所以出现异常。\n\n3..toString() 能够正常输出是由于`3.`  会被解释成浮点数，相当于对一个浮点数调用toString()\n\n\n### 2. 2 == [[[2]]]\n\n```js\n2 == [[[2]]]; \t\t\t// true\nvar a = [0, 1, 2, 3];\t\na[[2]] === a[2];\t\t// true\n[[[[[[[2]]]]]]] == 2;\t//true\n\n```\n\n对于非严格相等， JavaScript比较规则如下([ECMAScript® 2015 Language Specification](http://www.ecma-international.org/ecma-262/6.0/#sec-abstract-equality-comparison)):\n\n```js\nReturnIfAbrupt(x).\nReturnIfAbrupt(y).\nIf Type(x) is the same as Type(y), then\nReturn the result of performing Strict Equality Comparison x === y.\nIf x is null and y is undefined, return true.\nIf x is undefined and y is null, return true.\nIf Type(x) is Number and Type(y) is String,\nreturn the result of the comparison x == ToNumber(y).\nIf Type(x) is String and Type(y) is Number,\nreturn the result of the comparison ToNumber(x) == y.\nIf Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.\nIf Type(y) is Boolean, return the result of the comparison x == ToNumber(y).\nIf Type(x) is either String, Number, or Symbol and Type(y) is Object, then\nreturn the result of the comparison x == ToPrimitive(y).\nIf Type(x) is Object and Type(y) is either String, Number, or Symbol, then\nreturn the result of the comparison ToPrimitive(x) == y.\nReturn false.\n```\n\n所以当`2 == [[[2]]]` 比较时， [[[2]]] 会被转换成原始类型，相当于执行了\n\n```js\n2 === Number([[[2]]].valueOf().toString()) \n```\n所以结果是true\n\n而`a[[2]] === a[2]` 比较时由于a[] 里面需要的是数字或字符串， 所以`[2]` 会被转换成数字或字符串，所以相当于a[2]\n\n### 3. Number上的一些坑\n\n```js\nNumber.MIN_VALUE > 0; //true\ntypeof NaN\t//number\nNaN === NaN\t//false\n```\n上面第一个 `Number.MIN_VALUE` 其中`MIN_VALUE`返回的是大于零的最小数字，这个很容易被误解。\n第二个NaN从字面上看应该是\"Not a Number\", 但是ECMA Spec对 [Number type](http://www.ecma-international.org/ecma-262/5.1/#sec-4.3.20) 定义为`set of all possible Number values including the special “Not-a-Number” (NaN) values, positive infinity, and negative infinity` , 所以NaN、Number.NEGATIVE_INFINITY、Number.POSITIVE_INFINITY都是Number类型的。\n第三个NaN === NaN表面上看起来应该是相等的，但是ECMA上对严格相等 [The Strict Equality Comparison Algorithm](http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.6) 定义中有\n```\nIf Type(x) is Number, then\nIf x is NaN, return false.\nIf y is NaN, return false.\nIf x is the same Number value as y, return true.\nIf x is +0 and y is −0, return true.\nIf x is −0 and y is +0, return true.\nReturn false.\n```\n由于NaN类型是Number，可见不管任何数与NaN相比较，均会返回false。\n\n### 4. String字面量的instanceof\n\n```js\n\"string\" instanceof String;\t//false\nvar string = new String('string');\nstring instanceof String;\t//true\n```\nJavaScript中字符串分两种，一种是字面量的，一种是Object的，对于字面量的字符串，并不是String的instance。 所以通常判断类型是不是字符串通常使用\n```js\ntypeof(s) === 'string' || s instanceof String;\n//或者\n'string'.constructor === String;\n```\n\n### 5. ==的一些问题\n\nJavaScript推荐使用严格相等`===` , 因为非严格相等经常会出现一些问题\n\n```js \nundefined == null //true\n\"\" == false; // true \n[] == false; // true\n[] == ![];\t//true\nnull == false; // false\nnull == true; // false\n```\n\n对于第一行从上面第二条非严格相等的规则中可以知道是true。\n对于`\"\" == false` 由于Type(y) 是Boolean， 所以转换成Number， 即`0` ，此时由于Type(x)是String，所以根据规则，会转换成Number，即 `0` 从而得到相等。\n\n对于`[] == false` 比较复杂， 首先是`Type(y)` 是`Boolean`，转换成数字`0`, 由于`Type(x)`是`Object`，此时的`Type(y)`是`Number`，所以执行`ToPrimitive(x)`\n\n`ToPrimitive`规则如下\n> ToPrimitive(input, PreferredType?)\n\nPreferredType 可以是Number和String, 代表一个转换的偏好，结果不一定是该类型的，但是结果一定是一个原始类型的值。 如果PreferredType是Number会按照如下规则\n\n```js\n如果输入的值已经是个原始值,则直接返回它.\n否则,如果输入的值是一个对象.则调用该对象的valueOf()方法.如果valueOf()方法的返回值是一个原始值,则返回这个原始值.\n否则,调用这个对象的toString()方法.如果toString()方法的返回值是一个原始值,则返回这个原始值.\n否则,抛出TypeError异常.\n```\n\n如果是String，那么二三行会互换。如果没有的话，对于Date类型的对象会被设置成String，其它类型的会被设置成Number。\n\n由于`[].valueOf()` 依旧是`[]` , 所以会执行`toString()`方法转换成空字符串。\n所以相当于比较`\"\" == 0` 从而得到相等。\n\n对于`[] == ![]` 情况和上面一样，相当于比较`[] == false`.\n\n对于`null == true` 和 `null == false` 只能匹配到`Type(y)` 是`Boolean`这条，转换成数字，之后再没有规则能转换了，只能`return false`。\n\n\n\n\n\n\n\n\n\n\n","tags":["Javascript"]},{"title":"CSS Modules 简单入门","url":"/2016/05/26/css-modules/","content":"\nCSS的选择器在全局范围都会生效，比如有时候会有A写了 `btn` 的class定义了一个默认显示蓝色按钮， B之后不小心也写了一个 `btn` 的class， 很不幸，A需要的按钮样式可能被B所写的样式覆盖！ Bootstrap中的类似btn这种情况，在 `btn` 的class 通常定义的是所有按钮通用的样式，并且通过在定义 `btn-success`、`btn-error` 等样式通过选择器优先级来实现不同的样式。但是这种依旧相当于在全局中定义了样式， 无法避免将来有人不经意的又写了`btn-success`这样的class覆盖或者影响了之前的样式。\n\n为了解决这问题，前端大牛们提出了种种的命名约定来避免命名冲突。 比如[OOCSS](http://oocss.org/)、[SMACSS](https://smacss.com/)、[BEM](https://en.bem.info/methodology/naming-convention/)、[SUIT](https://suitcss.github.io/)等等。 以BEM为例，class的名字以`block__element--modifier`这种方式来命名，比如写个Menu， 那么Menu中的item处于active状态就要命名成 `menu__item--active` 这样的写法可能会解决问题，但是写起来总感觉有些反人类。所以有人说[BEM很火,看着就想吐](http://weibo.com/1960954893/Ac2LAgIjn?type=comment) . 并没有在项目中实践BEM这种命名方式，但是它来解决命名冲突的思路还是挺不错的，相当于通过模块命名前缀的方式避开在全局空间下命名，每个组件在它所属的命名空间下定义。\n\n<!-- more -->\n\n直到2014年Christopher Chedeau 在NationJS中所讲的[CSS in JS](http://blog.vjeux.com/2014/javascript/react-css-in-js-nationjs.html), 前端衍生出两个流派，一个主张彻底抛弃CSS，在JS中来写样式，并且从中衍生出[React Style](https://github.com/js-next/react-style)、 [jsxstyle](https://github.com/petehunt/jsxstyle)、 [Radium](https://github.com/FormidableLabs/radium)等实现。\n\nCSS in JS 好处虽多，但是也有一些不便之处，比如无法使用css预处理器、调试困难、无法使用像PostCSS这样的CSS常用工具等。\n\n在此基础上[CSS Modules Team](https://github.com/orgs/css-modules/people) 提出的CSS Modules显的更加实用，我们还可以独立的写CSS文件，通过JS来管理样式依赖。\n\n最近使用Mithril.js写了个[小项目](https://github.com/liangshuai/git-history) 并且尝试实践CSS Modules ，最终的效果如下:\n\n文件结构\n\n```\n+---components\n|   +---LeftBar\n|   |       LeftBar.css\n|   |       LeftBar.js\n|   +---Nav\n|   |       Nav.css\n|   |       Nav.js\n|   +---...\n```\n\n像写普通CSS一样写CSS文件，以Nav.css为例(CSS Modules 推荐驼峰式命名)\n\n```css\n.list {\n    margin: 0;\n    padding: 3px 10px;\n    list-style: none;\n    line-height: 1.5;\n    color: #9c9c9c;\n}\n\n.item {\n    margin: 0;\n    display: inline-block;\n    position: relative;\n    margin-left: 20px;\n}\n```\n\n在JavaScript中引用css文件，并且定义元素的class。这里使用了[Webpack](https://webpack.github.io/)，[Browersify](http://browserify.org/)也可以实现。\n\n```javascript\nimport m from 'mithril';\nimport styles from './Nav.css';\n\nvar Nav = module.exports = {\n    controller: function() {\n    },\n\n    view: function(ctrl) {\n        return m(\"nav\", {class: styles.nav}, [\n            m(\"ul\", {class: styles.list}, [\n                m('li', {class: styles.item}, [\n                    m('i.fa.fa-folder-o'),\n                    'Git History'\n                ]),\n                m('li', {class: styles.item}, [\n                    m('i.fa.fa-file-text-o'),\n                    'index.js'\n                ])\n            ])\n        ]);\n    }\n};\n\n```\n\n最终生成的效果如下：\n\n\n![CSS Module Screenshot](https://ooo.0o0.ooo/2017/03/04/58ba0a05b9c87.png)\n\n\n其中生成的Class Name依赖于具体的配置规则，示例中的WebPack Loader配置如下：\n\n```js\nloaders: [\n  { test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/ },\n  { test: /\\.css$/, loader: ExtractTextPlugin.extract('style-loader', 'css-loader?modules&importLoaders=1&localIdentName=[name]__[local]___[hash:base64:5]!postcss-loader') }\n]\n```\n\nCSS文件里面的选择器通过在JS中import之后引用，Webpack会自动处理，这样我们就可以既避免BEM那种反人类的写法，又享受到模块化命名。\n\n### 命名方式\n\nCSS Modules推荐驼峰式命名，但是并不是强制的。需要注意的是在写样式的时候不推荐像Bootstrap那样通过选择器优先级来覆盖，一个Class应该包含该Class所有的样式，这样所有的组件、元素都是相对独立的。以btn的不同状态为例\n\n```css\n/* BootStrap是这样实现 */\n.btn {}\n.btn-default {} /* 在`btn`的基础上定义`default`样式，HTML中需要同时引用 `btn` 和 `btn-default` */\n.btn-success {} /* 在`btn`的基础上定义`success`样式，HTML中需要同时引用 `btn` 和 `btn-success` */\n\n/* CSS Modules 推荐方式 */\n\n.default {} /* 包含所有default的样式, html中仅仅引用`default` 的就可以，此处的命名也不用加btn前缀 */\n.success {} /* 包含所有success的样式, html中仅仅引用`success` 的就可以 */\n\n```\n\nCSS Modules组件里面Class命名不需要再加模块名的前缀，一般Webpack/Browserify配置好之后就能自动生成出来，类似BEM那样，模块名通常都以文件名来命名了。\n\n### Composition\n\n上面说到一个Class应该包含它自身所需要的所有样式，但是并不意味着需要重复大量的代码， 用过Sass的应该比较熟悉@extend，在CSS Modules中也有类似的，叫Composition。\n\n```css\n.common {} /* 定义公用样式 */\n.default{\n    composes: common;\n    ...\n}\n.success{\n    composes: common;\n    ...\n}\n\n```\n如果使用了composes的话，必须在其它样式之前声明，composes也可以声明多个，使用 `composes: commonA commonB`\n\n\n### Global 范围的样式\n\n有时候需要写一些全局范围的样式，比如经常使用的clearfix， CSS Modules提供了:global\n\n```css\n:global(.clearfix::after) {\n    content: '';\n    clear: both;\n    display: table;\n}\n//或者这种\n:global .clearfix {\n    \n}\n.menu:global(.active) {\n}\n\n```\n\n### 依赖管理\n\n如果需要引入外部文件的样式也可以使用composes\n\n```css\n.default{\n    composes: common from '../common.css';\n}\n\n```\n### 定义变量\n\n如果使用了postcss和[postcss-modules-values](https://github.com/css-modules/postcss-modules-values) 就可以像Sass/Less一样使用变量\n\n比如\n\n*fontsize.css*\n```css\n@value large: 2rem;\n@value middle: 1.5rem;\n@value small: 1rem;\n\n```\n\n*Nav.css*\n```css\n@value fontsize: './fontsize.css';\n@value large, middle, small from fontsize;\n\n.list {\n    font-size: large;\n}\n```\n\n### 总结\n\nCSS Modules是目前实现CSS组件化最可行的方案之一，相对于其它实现，学习成本也会小很多，同时也能充分结合CSS生态工具(Sass/Less/Postcss等)和JS模块化能力。\n\n\n","tags":["CSS","Web组件","CSS Modules"]},{"title":"CentOS 7开放端口和关闭防火墙","url":"/2015/12/29/centos-firewall/","content":"\n想用CentOS + Vagrant搭建一个开发环境，搭建之后发现一直无法访问虚拟机中的服务，起初以为是Vagrant配置的问题，尝试修改配置，可是发现都不行，甚至连端口转发的方式都无法访问，于是猜测是因为CentOS7防火墙的关系，试了试打开端口和关闭防火墙，发现都可以访问到了。\n\n\n\n<!-- more -->\n\n```sh\n#vagrant 配置\nconfig.vm.network \"forwarded_port\", guest: 3000, host: 3000\nconfig.vm.network \"private_network\", ip: \"192.168.33.10\"\n# config.vm.network \"public_network\"\n```\n\n### 开放端口\n\n永久的开放需要的端口\n\n```sh\nsudo firewall-cmd --zone=public --add-port=3000/tcp --permanent\nsudo firewall-cmd --reload\n```\n之后检查新的Rule\n\n```sh\nfirewall-cmd --list-all\n```\n\n### 关闭防火墙\n\n由于只是用于开发环境，所以打算把防火墙关闭掉\n```sh\n//临时关闭防火墙,重启后会重新自动打开\nsystemctl restart firewalld\n//检查防火墙状态\nfirewall-cmd --state\nfirewall-cmd --list-all\n\n//Disable firewall\n\nsystemctl disable firewalld\nsystemctl stop firewalld\nsystemctl status firewalld\n\n//Enable firewall\n\nsystemctl enable firewalld\nsystemctl start firewalld\nsystemctl status firewalld\n```","tags":["CentOS","Vagrant","Firewall"]},{"title":"Express配置HTTPS服务器","url":"/2015/11/04/https-over-express/","content":"\n\n项目部署到生产环境下，出现了一个Bug，同样的代码在DEV环境下却是好的，怀疑是HTTPS导致的问题，所以在本地搭了一个HTTPS的服务器用来测试。\n\n整个过程还是很简单的，简单记录一下。\n\n<!-- more -->\n\n### 创建一个Express项目\n\n```sh\nexpress -e https-example\ncd https-example\nnpm install\n```\n\n### 使用OpenSSL生成证书文件\n\n```sh\nopenssl genrsa -out privatekey.pem 1024\nopenssl req -new -key privatekey.pem -out certrequest.csr\nopenssl x509 -req -in certrequest.csr -signkey privatekey.pem -out certificate.pem\n```\n\n\n### 修改app.js配置HTTPS\n\n```js\nvar fs = require('fs'),\n    https = require('https'),\n    express = require('express'),\n    app = express();\n    app.use(express.static('public'));\n    https.createServer({\n      key: fs.readFileSync('privatekey.pem'),\n      cert: fs.readFileSync('certificate.pem')\n    }, app).listen(8888);\n```\n\n### 运行Server\n\n```sh\nnode app.js\n\n```","tags":["Node.js","Express","Server","HTTPS"]},{"title":"为多个Git仓库配置SSH Key","url":"/2015/07/15/git-mutilple-host-ssh-key/","content":"\n在使用Git做版本控制的时候, 如果使用了远程仓库的话通常有两种连接方式，一种是HTTPS的，另一种是SSH的，\n由于远程仓库需要一定的权限才能操作，所以需要认证。如果使用了HTTPS这种方式就需要每一次与远程仓库之间交互都需要输入用户名和密码，而SSH会使用SSH认证方式来连接，只要简单的配置一次即可，不需要每次都输入，所以通常都会选择使用SSH的方式。\n使用SSH方式连接的话需要配置SSH Key和配置用户名和密码\n<!-- more -->\n\n![git](http://ww4.sinaimg.cn/large/a15b4afegw1eu36wmvgorj20ir01swel)\n\n\n### 添加SSH Key\n\n1. 生成SSH Key\n\n首先配置用户名和Email,\n\n```\n$ git config --global user.name 'your_name'\n\n$ git config --global user.email 'your_mail'\n\n```\n\n把your_name替换成自己的名称，your_mail 替换成你的邮箱，比如mail@liangshuai.me\n\n在Git Bash或者Terminal里面运行\n\n```sh\n$ ssh-keygen -t rsa -C \"your_mail\"\n```\n\nyour_mail应该与前面的保持一致。\n然后会让输入保存key的文件名\n\n```\nGenerating public/private rsa key pair. \nEnter file in which to save the key (/home/user_name/.ssh/id_rsa):\n\n```\n\n可以输入一个名称来标识，比如\n\n```\nid_rsa_home\n\n```\n\n之后一直回车即可在~/.ssh/(~表示用户目录)目录下生成id_rsa_home和id_rsa_home.pub，前者是SSH的私钥，后者是公钥，需要把公钥配置到Git 远程仓库。以GitHub为例，\n\n![ssh-key](http://ww4.sinaimg.cn/large/a15b4afegw1eu38vg831cj20u50mvjv8)\n\n\n先点击1 处之后点 `Settings` 之后点击3处\n\n在Key里面粘贴id_rsa_home.pub里面的内容，Title填写一个用来标识。\n\n保存之后就可以使用了。\n\n### 多个远程仓库配置SSH Key\n\n如果有同一台电脑需要连接多个远程仓库，比如同时使用Github和Gitlab或者BitBucket,这是就需要为多个远程仓库配置SSH Key，以再添加Gitlab仓库为例\n\n1. 生成Gitlab的SSH\n\n```sh\n$ ssh-keygen -t rsa -C \"your_gitlab_repo_mail\"\n```\n\n之后可以输入另一个文件名称\n\n```\nid_rsa_gitlab\n\n```\n\n2. 多仓库配置\n\n在~/.ssh/目录里面添加config文件\n\n```sh\n$ cd ~/.ssh/\n$ touch config\n$ nano config\n\n```\n配置如下\n\n```\nHost github.com\n  HostName github.com\n  PreferredAuthentications publickey\n  IdentityFile ~/.ssh/id_rsa_home\n\nHost git.gitlab.com\n  HostName gitlab.com\n  PreferredAuthentications publickey\n  IdentityFile ~/.ssh/id_rsa_gitlab\n\n```\n可以使用Git客户端测试一下，如果可以连上，那就OK了，如果有问题，试试下面几步。\n\n之后删除已经缓存的Keys\n\n```sh\n$ ssh-add -D\n\n```\n\n可以使用\n\n```sh\n$ ssh-add -l\n```\n\n\n查看所有已经添加的Key\n\n如果缺少的话使用如下命令添加\n\n\n```sh\nssh-add ~/.ssh/id_rsa_company\nssh-add ~/.ssh/id_rsa_home\n\n```\n\n### 为不同的项目配置不同的User\n\n如果需要为不同的项目配置不同的User，可以在项目目录下配置\n\n\n```sh\n$ git config user.name \"your_name_1\"\n$ git config user.email \"your_email_2\" \n\n```","tags":["git","ssh","github"]},{"title":"Java设计模式修炼之道之单例模式","url":"/2015/07/07/java-singeton/","content":"\n\n单例模式顾名思义就是要保证某个类只被实例化一次，该模式常常用于窗口管理器、文件系统等代表那些本质上唯一的系统组件。由于要保证该类只能被实例化一次，所以就要求是该类自己创建自己的实例，因为如果能够别的类有能力来创建该类的实例的话就不能保证只有一个实例。为了使外界能够使用这个唯一的实例，单例类必须向外界提供自己的实例。创建单例的方式有以下几种:\n\n<!-- more -->\n\n### 饿汉式单例类\n\n``` java\npublic class EagerSingleton {\n\tprivate static final EagerSingleton instance = new EagerSingleton();\n\t// 私有构造函数，不可省略，需要确保别的类不能通过构造函数创建该类的实例\n\tprivate EagerSingleton() {}\n\tpublic static EagerSingleton getInstance() {\n\t\treturn instance;\n\t}\n}\n\n```\n\n\n这种方式在类被加载时初始化实例，构造方法是private，所以外界不能直接创建该类的实例。这种方式创建单例类的优缺点如下:\n优点:相对于后面介绍的懒汉式单例类来说节省了时间\n缺点:\n* 牺牲了空间，因为类一加载就需要创建单例\n* 不能算是饿汉式特有的缺点，但是却是需要注意的是防止某些客户端通过反射机制设置构造方法的setAccessible(true),从而拥有可以直接创建实例的能力。测试程序如下:\n\n\n``` java\npublic class EagerSingleton {\n    private static final EagerSingleton instance=new EagerSingleton();\n    //私有构造函数，不可省略，需要确保别的类不能通过构造函数创建该类的实例\n    private EagerSingleton(){}\n    public static EagerSingleton getInstance(){\n                    return instance;\n    }\n    public static void main(String[] args) throws IllegalArgumentException, InstantiationException, IllegalAccessException,InvocationTargetException {\n                    EagerSingleton es1=EagerSingleton.getInstance();\n                    EagerSingleton es2=EagerSingleton.getInstance();\n                    System.out.println(es1==es2);\n                    for (java.lang.reflect.Constructor<?>c:es1.getClass().getDeclaredConstructors()) {\n                                   c.setAccessible(true);\n                                   EagerSingleton es3=(EagerSingleton) c.newInstance();\n                                   System.out.println(es2==es3);\n                    }\n    }\n}\n\n```\n\n\n可以看到输出结果如下：\n\n```sh\ntrue\nfalse\n\n```\n\n这说明es3和es2是引用的不同的对象。\n\n解决该问题的一个思路如下:\n\n``` java\npublic class EagerSingleton {\n\tprivate static int count=0;\n\tprivate static final EagerSingleton instance=new EagerSingleton();\n\t//私有构造函数，不可省略，需要确保别的类不能通过构造函数创建该类的实例\n\tprivate EagerSingleton(){\n\t\tif(count==1){\n\t\t\tthrow new RuntimeException(\"只能初始化一次\");\n\t\t}\n\t\tcount++;\n\t}\n\tpublic static EagerSingleton getInstance(){\n\t\treturn instance;\n\t}\n}\n\n```\n\n\n### 懒汉式单例类\n\n介绍懒汉式单例类之前先介绍几种使用懒汉式单例类的几种常见的不恰当的例子：\n\n* 如下这种懒汉式单例是错误频率比较高的一种，其错误的原因是该单例类只能在单线程的环境中正确使用。如果在多线程的环境中，如果线程A和线程B同时进入getInstance中，如果其中一个线程判断instance==null，进入了if的代码块正在或者还没有开始实例化LazySingleton或者实例化结束尚未把实例引用赋给instance，此时线程B就会再次进入if代码块，造成系统中有超过一个的单例类实例\n\n\n``` java\npublic class LazySingleton {\n\tprivate static LazySingleton instance = null;\n\tprivate LazySingleton() {\n\t}\n\tpublic static LazySingleton getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new LazySingleton();\n\t\t}\n\t\treturn instance;\n\t}\n}\n\n\n```\n\n\n* 同步化getInstance方法，这样做可以保证是单例的，但是由于每一次获取实例都只能有一个方法进入getInstance方法，所以效率相对比较低。但是总的来说这是一个正确的单例模式实现方式。\n\n``` java\npublic static synchronized LazySingleton getInstance()  \n\n```\n\n* 所谓的\"双重检查加锁\"，这种方式的代码如下，可以说很大程度上这种方式被一些人误认为是解决第2条效率低的比较好的方式，因为只有在第一次获取实例的时候才会进入加锁的代码块，以后就再不用加锁了。可是需要注意的是这种双重检查加锁的机制在Java中是行不通的，原因如下:\n对象初始化和引用赋值的顺序是不可预料的\n这句话怎么理解呢，在这里new LazySingleton()的过程中会先为对象分配内存空间和对象属性的赋值，之后就可将引用地址传递给instance变量，可是这个时候对象的初始化过程有可能并没有完成，这个时候如果另外一个线程进入getInstance就会得到一个并没有完成初始化的状态不正确的对象，从而造成崩毁，这个地方需要特别注意。\n\n\n``` java\npublic class LazySingleton {\n\tprivate static LazySingleton instance=null;\n\tprivate LazySingleton(){}\n\tpublic static LazySingleton getInstance(){\n\t\tif(instance==null){\n\t\t\tsynchronized (LazySingleton.class) {\n\t\t\t\tif(instance==null){\n\t\t\t\t\tinstance=new LazySingleton();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n}\n\n\n```\n\n\n### 类级内部类式单例类\n\n上面的懒汉式和饿汉式实现方式各有利弊，类级内部类单例类可以说兼顾了两者的优点，可谓是单例模式最好的实现方式之一。\n先来看看什么是类级内部类，类级内部类是指由static修饰的成员式内部类，相当于类的static成分，它的对象与外部类间不存在依赖关系，可以直接创建。类级内部类可以定义静态方法，静态方法中只能够引用外部类中的静态成员方法或者成员变量。类级内部类相当于其外部类的成员，只有在第一次被使用的时候才会被加载。\n\n``` java\npublic class StaticInnerClassSingleton {\n\tprivate StaticInnerClassSingleton() {}\n\tprivate static class SingletonHolder{\n\t\t//静态初始化，由JVM来保证线程安全\n\t\tprivate static StaticInnerClassSingleton instance=new StaticInnerClassSingleton();\n\t}\n\tpublic static StaticInnerClassSingleton getInstance(){\n\t\treturn SingletonHolder.instance;\n\t}\n}\n\n```\n\n\n上面的代码中同步已经由JVM执行了，JVM在以下情况下会进行同步控制。\n\n* 由静态初始化器(静态字段上或static{}块中的初始化器)初始化数据时\n* 访问final字段时\n* 在创建线程之前创建对象时\n* 线程可以看见它将要处理的对象时\n\n\n这种单例模式只有在第一次调用getInstance的时候读取SingletonHolder.instance时初始化，同时由于是SingletonHolder的静态字段，所以JVM会保证它的线程安全性。\n\n\n### 枚举式单例类\n\n按照《高效Java 第二版》中的说法：单元素的枚举类型已经成为实现Singleton的最佳方法。用枚举来实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。\n\n\n``` java\npublic enum Singleton {\n    /**\n     * 定义一个枚举的元素，它就代表了Singleton的一个实例。\n     */\n    uniqueInstance;\n    /**\n     * 单例可以有自己的操作\n     */\n    public void singletonOperation(){\n        //功能处理\n    }\n}\n\n```\n\n使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。","tags":["Java","单例","Singeton"]},{"title":"Ajax跨域问题解决方案","url":"/2015/02/11/ajax-cross-domain/","content":"JavaScript出于同源策略[Same-origin policy](http://en.wikipedia.org/wiki/Same-origin_policy)，对跨域问题作了限制，不同域的客户端脚本是不能发送请求其它域。同源策略是浏览器最核心也是最基本的安全功能，所有的浏览器(注意这里说的是浏览器，移动开发中的WebView并不是浏览器，所以是可以跨域的!)都已经实现了同源策略。但是项目中经常因为各种原因，可能会遇到跨域问题。\n\n<!-- more -->\n\n###怎么样算是跨域?\n\n* 协议不同(比如HTTP协议和HTTPS协议)\n* 域名不同(比如 a.com和 b.com，也包含子域的情况，例如 a.com和 www.a.com)\n* 端口不同(例如 http://a.com/ 和 http://a.com:8080/)\n\n满足以上任意一种情况均属于跨域\n\n###怎么解决跨域问题\n\n* 通过CORS方式\n* 通过JSONP方式\n* 通过Apache/Nginx反向代理方式\n* 通过动态构建Script\n\n#### 通过CORS方式\n\n[CORS](http://en.wikipedia.org/wiki/Cross-origin_resource_sharing)是新的[W3C](http://www.w3.org/TR/cors/)策略,它定义了在跨域访问资源时浏览器和服务器之间如何通信。\nCORS的基本思想是使用自自定义的HTTP头部允许浏览器和服务器之间相互了解对象，从而\n决定请求或响应成功与否。浏览器在发送POST请求的时候会在Request Headers里面包含Origin属性\n来向服务器端标识请求是从哪里发起的。服务器端对CORS支持是通过Access-Control-Allow-Origin\n来进行的，如果Access-Control-Allow-Origin里面允许来自Origin的请求，那么就可以实现跨域。\n下面用Java 的[Spark](http://sparkjava.com/)微框架+Velocity举例说明\n\n源码在 https://github.com/liangshuai/cors_demo\n\n\n``` java\n\npublic class App\n{\n    public static void main( String[] args )\n    {\n      port(80);\n      staticFileLocation(\"/public\");\n      get(\"/\", (req, res) -> {\n        Map<String,Object> attributes = new HashMap<>();\n        attributes.put(\"message\", \"Spark World\");\n        attributes.put(\"templateName\", \"index.vm\");\n        return new ModelAndView(attributes, \"layout.vm\");\n      },new VelocityTemplateEngine());\n    }\n}\n\n```\n\n上面的代码会在80端口上启动一个Server，仅仅包含一个页面，页面上包含一个按钮，点击该按钮会向http://localhost:8080/cors 发送Ajax Post请求，很明显端口号不同，所以是跨域的，默认情况下\n\nAjax Request代码如下\n\n\n``` javascript\n\n$(\".btn-primary\").click(function(){\n     $.post(\"http://localhost:8080/cors\",function(result){\n      $(\"p\").text(result);\n    });\n  });\n\n```\n\n![cors demo ](https://ooo.0o0.ooo/2017/03/04/58ba094dd12a2.jpg)\n\n监听8080端口的Server代码如下\n\n``` java\n\npublic class CorsServer\n{\n    public static void main( String[] args )\n    {\n        port(8080);\n        post(\"/cors\", (req, res) -> {\n          /*res.header(\"Access-Control-Allow-Origin\", \"*\");*/\n          return \"Response from cross domain\";\n        });\n\n    }\n}\n\n```\n\n上面的*代表通配符，匹配所有来源的Request\n\n\n\n此时点击\"Send CORS Request\"按钮，会发现Chrome Console中提示\n\n![Access-Control-Allow-Origin](https://ooo.0o0.ooo/2017/03/04/58ba097d187aa.jpg)\n\n取消CorsServer 中的注释，并且再次运行，重新点击按钮会发现\n\n![ajax cors](https://ooo.0o0.ooo/2017/03/04/58ba09abc9e26.jpg)\n\n可以看到已经可以成功POST请求。\n\n这个例子简单演示可CORS的原理，实际项目中这样用是非常危险的，关于CORS的安全防范可以参考[HTML5安全风险详析之一：CORS攻击](http://blog.csdn.net/hfahe/article/details/7961566)\n\n#### 通过JSONP方式\n\n[JSONP](http://en.wikipedia.org/wiki/JSONP) 是JSON的一种使用模式，可以用来解决主流浏览器的跨域数据访问问题，也就是上面所说的同源策略。JSONP实质上并不是使用Ajax请求，而是想引入正常的JS文件(引用普通的JS文件、图片等都不存在跨域问题)一样，\n只不过这个JS文件是动态生成，关于JSONP的详细介绍了一看[说说JSON和JSONP，也许你会豁然开朗，含jQuery用例](http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html) ,这篇博文中详细介绍了JSONP的原理和用法，写的非常详细。\n\n#### 通过Apache/Nginx反向代理方式\n\n反向代理的方式原理是让Ajax请求同域下的资源，该资源再被反向代理拦截，转发至异域，这样就绕开了浏览器的限制。\n\n使用反向代理的方式不仅仅可以用来解决跨域问题，还可以用来解决一下问题:\n* 请求的统一控制，包括设置权限、过滤规则等\n* 隐藏内部服务真实地址，暴露在外的只是反向代理服务器地址\n* 实现负载均衡，内部可以采用多台服务器来组成服务器集群，外部还是可以采用一个地址访问\n* 作为真实服务器的缓冲，解决瞬间负载量大的问题\n\n仍以前面的例子为例，修改App类的让其监听8000端口\n\n```java\n\nport(8000);\nstaticFileLocation(\"/public\");\n\n```\n\n同时注释掉CorsServer类Access-Control-Allow-Origin 所在行。\n\n以Nginx为例，设置反向代理，修改conf/nginx.conf里面配置\n\n``` conf\n\nserver {\n        listen       80;\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            proxy_pass    http://localhost:8000/;\n        }\n        location /cors{\n            proxy_pass http://localhost:8080/cors;\n        }\n\n        ...\n\n}\n\n```\n\n同时修改Ajax Request 的URL\n\n``` javascript\n\n$(\".btn-primary\").click(function(){\n     $.post(\"http://localhost/cors\",function(result){\n      $(\"p\").text(result);\n    });\n  });\n\n```\n\n启动Nginx之后打开 http://localhost/ 测试,可以看到能够正确显示8080的Response内容\n","tags":["Ajax","cross domain","jsonp","Access-Control-Allow-Origin"]}]